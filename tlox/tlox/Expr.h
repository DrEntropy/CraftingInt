// Generated by GenerateAst.py

#ifndef Expr_h
#define Expr_h
#include<vector>
#include "Token.h"


class Expr;
class Stmt;
class Assign;
class Binary;
class Call;
class Grouping;
class AnonFunction;
class Literal;
class Logical;
class Unary;
class Variable;
class Expr
{
public:

    class Visitor
    {
    public:
        virtual void visit(Assign& el)=0;
        virtual void visit(Binary& el)=0;
        virtual void visit(Call& el)=0;
        virtual void visit(Grouping& el)=0;
        virtual void visit(AnonFunction& el)=0;
        virtual void visit(Literal& el)=0;
        virtual void visit(Logical& el)=0;
        virtual void visit(Unary& el)=0;
        virtual void visit(Variable& el)=0;
    };

    virtual void accept(Visitor& v) = 0;
};

class Assign : public Expr
{
public:
    Assign(Token name, std::shared_ptr<Expr> value):name{name}, value{value}{}

   void accept(Visitor& v) override
    {
        return v.visit(*this);
    }

    Token name;
    std::shared_ptr<Expr> value;

};

class Binary : public Expr
{
public:
    Binary(std::shared_ptr<Expr> left, Token op, std::shared_ptr<Expr> right):left{left}, op{op}, right{right}{}

   void accept(Visitor& v) override
    {
        return v.visit(*this);
    }

    std::shared_ptr<Expr> left;
    Token op;
    std::shared_ptr<Expr> right;

};

class Call : public Expr
{
public:
    Call(std::shared_ptr<Expr> callee, Token paren, std::vector<std::shared_ptr<Expr>> arguments):callee{callee}, paren{paren}, arguments{arguments}{}

   void accept(Visitor& v) override
    {
        return v.visit(*this);
    }

    std::shared_ptr<Expr> callee;
    Token paren;
    std::vector<std::shared_ptr<Expr>> arguments;

};

class Grouping : public Expr
{
public:
    Grouping(std::shared_ptr<Expr> expression):expression{expression}{}

   void accept(Visitor& v) override
    {
        return v.visit(*this);
    }

    std::shared_ptr<Expr> expression;

};

class AnonFunction : public Expr
{
public:
    AnonFunction(std::vector<Token> params, std::vector<std::shared_ptr<Stmt>> body):params{params}, body{body}{}

   void accept(Visitor& v) override
    {
        return v.visit(*this);
    }

    std::vector<Token> params;
    std::vector<std::shared_ptr<Stmt>> body;

};

class Literal : public Expr
{
public:
    Literal(Value value):value{value}{}

   void accept(Visitor& v) override
    {
        return v.visit(*this);
    }

    Value value;

};

class Logical : public Expr
{
public:
    Logical(std::shared_ptr<Expr> left, Token op, std::shared_ptr<Expr> right):left{left}, op{op}, right{right}{}

   void accept(Visitor& v) override
    {
        return v.visit(*this);
    }

    std::shared_ptr<Expr> left;
    Token op;
    std::shared_ptr<Expr> right;

};

class Unary : public Expr
{
public:
    Unary(Token op, std::shared_ptr<Expr> right):op{op}, right{right}{}

   void accept(Visitor& v) override
    {
        return v.visit(*this);
    }

    Token op;
    std::shared_ptr<Expr> right;

};

class Variable : public Expr
{
public:
    Variable(Token name):name{name}{}

   void accept(Visitor& v) override
    {
        return v.visit(*this);
    }

    Token name;

};

#endif
